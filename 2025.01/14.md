# 실제 코드에서 리액트 컴파일러의 성능
리액트의 리렌더링은 부모->자식들로 연쇄적으로 일어난다

붎필요한 리렌더링을 방지하기 위한 방법들:
- 상태를 하위 컴포넌트로 이동시키기
- 컴포넌트를 prop으로 전달시키기
- 전역 상태 관리로 prop drilling 방지 (하지만 전역 상태 관리는 모듈 간 의존성을 발생시킬 수 있기 때문에 신중하게 고려하고 도입할 것)
- memoization

리액트에서 메모이제이션은 memo, useMemo, useCallback이 이용된다

어떤 컴포넌트를 memo로 감싸면 일어나는 일: 
리액트가 트리에서 이 컴포넌트에 도달하면 멈춰서 프로퍼티(props)가 변경되었는지 체크 -> 변경이 없으면 리렌더링이 거기서 중단

props가 배열이나 객체인 경우:
리렌더링될 때마다 다시 생성되고 참조가 변경 -> 메모이제이션 작동 안 됨 -> 이 문제를 해결하려면 useMemo(배열,객체 값) useCallback(함수) 사용

그러나 useMemo, useCallback으로 코드를 도배해버리면 가독성이 엉망이 될 때가 생긴다

그래서 리액트에서는 야심차게 리액트 컴파일러는 출시하였다 (2024.10)
컴파일러는 일반 리액트 코드를 memo, useMemo, useCallback으로 자동으로, 내부적으로 감싸주는 역할을 한다.
가독성과 성능 두가지를 얻는 셈.

